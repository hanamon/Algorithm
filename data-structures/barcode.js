/*
  * [DFS] 바코드
  * 요구 사항 : 1, 2, 3으로만 이루어진 수열 바코드를 만든다.
  * - 바코드에서 인접한 두 개의 부분 수열이 동일하다면 제작할 수 없다고 할 때, 주어진 길이 len의 바코드 중 가장 작은 수를 반환하라.
  * 인자 : Number 타입의 1 이상 50 이하의 자연수
  * 출력 : String 타입을 리턴
  * - 예시로, 121도, 123도 전부 바코드로 제작할 수 있지만 제일 작은 수는 121이기 때문에 121을 반환해야 한다.
*/

/*
  * [부분수열 이란?]
  * 주어진 수열에서 연속된 모든 구간을 말한다.
  * 수열 123의 부분수열 => 1, 2, 3, 12, 23, 123
  * 
  * [인접한 두 부분수열 이란?]
  * 첫번째 부분수열과 두번째 부분수열이 연속된 경우를 말한다.
  * 
  * [수열 1234에서 인접한 부분수열]
  * 두 부분수열이 같은 지가 중요하므로 길이가 서로 다른 경우는 무시한다.
  * 1234 인접한 부분수열은 1과 2, 2와 3, 3과 4, 12와 34 이다.
*/

// 입출력 예시
let output = barcode(3);
console.log(output); // "121"

output = barcode(7);
console.log(output); // "1213121"

output = barcode(20);
console.log(output); // "12131231321231213123"

/*--------------------------------------------------------------*/

// [방법 1.]
function barcode(len, str = '') {
  // 0. 만약 문자열의 길이와 인자로 들어온 수가 같으면 문자열을 리턴한다.
  if( str.length === len ) return str;

  // 1. 반복문을 통해 1 부터 3 까지의 수를 문자열에 조합한 후 유효성검사한다.
  for( let i=1; i<=3; i++ ) {
    if( isValid(str + i) ) {
      // 2. 조합한 문자열이 유효성검사를 통과하면 다음에 이어질 문자 찾기위해 재귀를 호출한다.
      const result = barcode(len, str + i);
      if( result ) return result;
    }
    // 3. 조합한 문자열이 유효성검사를 통과하지 못하면 반복문에서 다음 번째 수를 문자열과 조합한다.
  }

  // 4. 조합한 문자열이 유효성검사를 통과하지 못하면 undefined 을 반환한다.
}

function isValid(str) {
  // 최대 절반 길이만큼만 두 개의 부분 수열이 가능하다.
  const halfLen = Math.floor(str.length / 2);
  // 새로운 수가 문자열에 추가되었을 때, 비교를 편하게 하기 위해 문자열을 뒤집는다.
  const reversed = str.split('').reverse().join('');
  // 모든 길이에 대해서 순차적으로 유효성을 검사하기 때문에,
  // 문자열의 길이보다 보다 짧은 길이의 문자열은 이미 유효성을 통과했다.
  // 예: '121'이 들어왔을 때 '12'는 이미 통과된 상태이다.
  // 즉, 입력받은 문자열이 뒤집힌 상태에서 처음부터 시작하는 부분 수열만 고려하면 된다.
  for( let i=1; i<=halfLen; i++ ) {
    if( reversed.slice(0, i) === reversed.slice(i, i + i) ) return false;
  }
  return true;
}
