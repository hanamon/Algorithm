/*
  * [병합 정렬 알고리즘]
  * 요구 사항 : 수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴한다.
  * 입력 : 수를 요소로 갖는 배열, arr[i]의 길이는 100,000 이하
  * 출력 : 수를 요소로 갖는 배열, 오름차순으로 정렬된 배열
  * 주의 사항 :
  * 1. 병합 정렬을 구현한다.
  * 2. arr.sort 사용은 금지된다.
  * 입력 : mergeSort( [1, 0, 43, 100, -10, 0, 100, 21, 0] ); 
  * 출력 : [-10, 0, 0, 0, 1, 21, 43, 100, 100]
*/

/*--------------------------------------------------------------*/

/*
  * [병합 정렬은?]
  * 병합 정렬은 표준 라이브러리에서 정렬을 구현할 때 퀵 정렬이나 힙 정렬의 대안으로 사용하는 최적화된 정렬 알고리즘이다.
  * 병합 정렬은 두 가지 방식으로 구현 가능하다.
  * 재귀적 접근(위->아래) 그리고 반복적 접근(아래->위)
  * 
  * [병합 정렬 알고리즘 로직]
  * 1. N의 길이를 가진 배열 리스트를 1의 길이를 가진 "부분 리스트"가 N개 모인 것으로 취급한다.
  * 2. 인접한 부분 리스트들을 정렬하여 2의 길이를 가진 부분 리스트로 병합한다.
  * 3. 2의 길이를 가진 인접한 부분 리스트들을 4의 길이를 가진 부분 리스트로 합친다.
  * 4. 하나의 정렬된 리스트가 될 때까지 위 과정을 반복한다.
  * 5. N이 홀수라면, 첫 번째 병합 때 1의 길이를 가진 부분 리스트를 남긴다.
*/

/*--------------------------------------------------------------*/

/*
  [재귀적 접근]

  1. 주어진 배열을 절반으로 나뉜다.
    [4, 7, 4, 3, 9, 1, 2] => [4, 7, 4], [3, 9, 1, 2]
  2. 두 배열이 재귀적으로 정렬된다.
    [4, 7, 4] => [4, 4, 7], [3, 9, 1, 2] => [1, 2, 3, 9]
  3. 두 배열이 병합된다.
    [4, 4, 7], [1, 2, 3, 9] => [1, 2, 3, 4, 4, 7, 9]

  * 2단계에서 나뉘어진 각각의 배열 4, 7, 4에 대해서도 1-3번의 과정이 재귀적으로 똑같이 진행된다.

  1. 주어진 배열을 절반으로 나뉜다.
    [4, 7, 4] => [4], [7, 4]
  2. 두 배열이 재귀적으로 정렬된다.
    [7, 4] => [4, 7]
  3. 두 배열이 병합된다.
    [4], [4, 7] => [4, 4, 7]

  * 이 과정의 2단계에서 나뉘어진 7, 4에 대해서도 재귀가 호출된다.
  * 4는 원소가 하나이기 때문에 정렬하지 않아도 된다.

  1. 주어진 배열을 절반으로 나뉜다.
    [7, 4] => [7], [4]
  2. 두 배열이 재귀적으로 정렬된다.
    [7] => [7], [4] => [4]
  3. 두 배열이 병합된다.
    [7], [4] => [4, 7]

  * 모든 재귀 호출이 완료되면 3단계에서 병합이 되기 때문에 최종적으로 정렬된 하나의 배열이 리턴된다.
*/

// [방법 1.] - 재귀적 접근 (위 -> 아래)
const merge = function (left, right) {
  // left 와 right 로 나뉘어진 배열을 인자로 받는다.
  // 최소 요소를 1개씩 가지고 있다.
  let merged = [];

  let leftIdx = 0, rightIdx = 0;
  const size = left.length + right.length;

  // left 가 [3, 4] 이고 right 가 [1, 2] 이면 4번 반복한다.
  for( let i=0; i<size; i++ ) {
    // 처음에는 건너뛴다.
    // 세 번째 순번 부터 비교가 의미가 있다.
    // 모든 left 나 right 중 한 쪽 배열의 모든 요소를 merged 에 이미 push 된 상태이기 때문에
    // left 와 right 의 비교가 의미가 없다.
    // 그래서 그냥 남은 배열의 요소를 하나씩 push 한다.
    // (이게 가능한 이유는 재귀를 사용해서 가장 작은 length 부터 이미 정렬이 되어있기 때문이다.)
    if( leftIdx >= left.length ) {
      merged.push(right[rightIdx]);
      rightIdx++;
    }
    else if( rightIdx >= right.length ) {
      merged.push(left[leftIdx]);
      leftIdx++;
    }
    // left의 leftIdx 요소와 right 의 rightIdx 요소를 비교 후
    // 더 작은 요소를 merged 에 push 후 push 한 요소 다음 부터 비교하기 위해 해당하는 Idx 를 + 1 해준다.
    else if( left[leftIdx] > right[rightIdx] ) {
      merged.push(right[rightIdx]);
      rightIdx++;
    }
    else if( left[leftIdx] <= right[rightIdx] ) {
      merged.push(left[leftIdx]);
      leftIdx++;
    }
  }

  // 하나로 합쳐진 오름차순으로 정렬된 배열을 리턴한다.
  return merged;
};

const mergeSort = function (arr) {
  // 재귀 탈출 조건
  if (arr.length < 2) return arr;

  const middle = parseInt(arr.length / 2);

  // 1. 주어진 배열을 절반으로 나뉜다.
  const left = mergeSort(arr.slice(0, middle));
  const right = mergeSort(arr.slice(middle));

  // 2. 두 배열이 재귀적으로 병합 정렬된다.
  // (가장 작은 부분 부터 즉 left나 right의 길이가 1인 경우 부터 차례대로 mrege 함수를 통해 정렬된다.)
  const merged = merge(left, right);

  // 3. 병합 정렬된 배열을 리턴한다.
  return merged;
};
